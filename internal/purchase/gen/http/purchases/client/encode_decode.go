// Code generated by goa v3.5.2, DO NOT EDIT.
//
// purchases HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/jolinGalal/match/internal/purchase/design

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	purchases "github.com/jolinGalal/match/internal/purchase/gen/purchases"
	goahttp "goa.design/goa/v3/http"
)

// BuildDepositRequest instantiates a HTTP request object with method and path
// set to call the "purchases" service "deposit" endpoint
func (c *Client) BuildDepositRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id int64
	)
	{
		p, ok := v.(*purchases.DepositPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("purchases", "deposit", "*purchases.DepositPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DepositPurchasesPath(id)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("purchases", "deposit", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDepositRequest returns an encoder for requests sent to the purchases
// deposit server.
func EncodeDepositRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*purchases.DepositPayload)
		if !ok {
			return goahttp.ErrInvalidType("purchases", "deposit", "*purchases.DepositPayload", v)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewDepositRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("purchases", "deposit", err)
		}
		return nil
	}
}

// DecodeDepositResponse returns a decoder for responses returned by the
// purchases deposit endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeDepositResponse may return the following errors:
//	- "invalid-data" (type *goa.ServiceError): http.StatusNotAcceptable
//	- "dublicate-data" (type *goa.ServiceError): http.StatusNotAcceptable
//	- error: internal error
func DecodeDepositResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotAcceptable:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid-data":
				var (
					body DepositInvalidDataResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("purchases", "deposit", err)
				}
				err = ValidateDepositInvalidDataResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("purchases", "deposit", err)
				}
				return nil, NewDepositInvalidData(&body)
			case "dublicate-data":
				var (
					body DepositDublicateDataResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("purchases", "deposit", err)
				}
				err = ValidateDepositDublicateDataResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("purchases", "deposit", err)
				}
				return nil, NewDepositDublicateData(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("purchases", "deposit", resp.StatusCode, string(body))
			}
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("purchases", "deposit", resp.StatusCode, string(body))
		}
	}
}

// BuildBuyRequest instantiates a HTTP request object with method and path set
// to call the "purchases" service "buy" endpoint
func (c *Client) BuildBuyRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id int64
	)
	{
		p, ok := v.(*purchases.BuyPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("purchases", "buy", "*purchases.BuyPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: BuyPurchasesPath(id)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("purchases", "buy", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeBuyRequest returns an encoder for requests sent to the purchases buy
// server.
func EncodeBuyRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*purchases.BuyPayload)
		if !ok {
			return goahttp.ErrInvalidType("purchases", "buy", "*purchases.BuyPayload", v)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewBuyRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("purchases", "buy", err)
		}
		return nil
	}
}

// DecodeBuyResponse returns a decoder for responses returned by the purchases
// buy endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeBuyResponse may return the following errors:
//	- "invalid-data" (type *goa.ServiceError): http.StatusNotAcceptable
//	- "dublicate-data" (type *goa.ServiceError): http.StatusNotAcceptable
//	- "not-exist" (type *goa.ServiceError): http.StatusNotFound
//	- error: internal error
func DecodeBuyResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body BuyResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("purchases", "buy", err)
			}
			err = ValidateBuyResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("purchases", "buy", err)
			}
			res := NewBuyPurchesListOK(&body)
			return res, nil
		case http.StatusNotAcceptable:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid-data":
				var (
					body BuyInvalidDataResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("purchases", "buy", err)
				}
				err = ValidateBuyInvalidDataResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("purchases", "buy", err)
				}
				return nil, NewBuyInvalidData(&body)
			case "dublicate-data":
				var (
					body BuyDublicateDataResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("purchases", "buy", err)
				}
				err = ValidateBuyDublicateDataResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("purchases", "buy", err)
				}
				return nil, NewBuyDublicateData(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("purchases", "buy", resp.StatusCode, string(body))
			}
		case http.StatusNotFound:
			var (
				body BuyNotExistResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("purchases", "buy", err)
			}
			err = ValidateBuyNotExistResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("purchases", "buy", err)
			}
			return nil, NewBuyNotExist(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("purchases", "buy", resp.StatusCode, string(body))
		}
	}
}

// BuildResetRequest instantiates a HTTP request object with method and path
// set to call the "purchases" service "reset" endpoint
func (c *Client) BuildResetRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id int64
	)
	{
		p, ok := v.(*purchases.ResetPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("purchases", "reset", "*purchases.ResetPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ResetPurchasesPath(id)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("purchases", "reset", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeResetRequest returns an encoder for requests sent to the purchases
// reset server.
func EncodeResetRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*purchases.ResetPayload)
		if !ok {
			return goahttp.ErrInvalidType("purchases", "reset", "*purchases.ResetPayload", v)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeResetResponse returns a decoder for responses returned by the
// purchases reset endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeResetResponse may return the following errors:
//	- "invalid-data" (type *goa.ServiceError): http.StatusNotAcceptable
//	- "dublicate-data" (type *goa.ServiceError): http.StatusNotAcceptable
//	- error: internal error
func DecodeResetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotAcceptable:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid-data":
				var (
					body ResetInvalidDataResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("purchases", "reset", err)
				}
				err = ValidateResetInvalidDataResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("purchases", "reset", err)
				}
				return nil, NewResetInvalidData(&body)
			case "dublicate-data":
				var (
					body ResetDublicateDataResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("purchases", "reset", err)
				}
				err = ValidateResetDublicateDataResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("purchases", "reset", err)
				}
				return nil, NewResetDublicateData(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("purchases", "reset", resp.StatusCode, string(body))
			}
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("purchases", "reset", resp.StatusCode, string(body))
		}
	}
}

// marshalPurchasesProductsListToProductsListRequestBody builds a value of type
// *ProductsListRequestBody from a value of type *purchases.ProductsList.
func marshalPurchasesProductsListToProductsListRequestBody(v *purchases.ProductsList) *ProductsListRequestBody {
	res := &ProductsListRequestBody{
		ProductID:     v.ProductID,
		PurductAmount: v.PurductAmount,
	}

	return res
}

// marshalProductsListRequestBodyToPurchasesProductsList builds a value of type
// *purchases.ProductsList from a value of type *ProductsListRequestBody.
func marshalProductsListRequestBodyToPurchasesProductsList(v *ProductsListRequestBody) *purchases.ProductsList {
	res := &purchases.ProductsList{
		ProductID:     v.ProductID,
		PurductAmount: v.PurductAmount,
	}

	return res
}

// unmarshalProductInfoResponseBodyToPurchasesProductInfo builds a value of
// type *purchases.ProductInfo from a value of type *ProductInfoResponseBody.
func unmarshalProductInfoResponseBodyToPurchasesProductInfo(v *ProductInfoResponseBody) *purchases.ProductInfo {
	res := &purchases.ProductInfo{
		ProductName:       *v.ProductName,
		PurductAmount:     *v.PurductAmount,
		PurductUnitPrice:  *v.PurductUnitPrice,
		PurductTotalPrice: *v.PurductTotalPrice,
	}

	return res
}

// unmarshalChangesResponseBodyToPurchasesChanges builds a value of type
// *purchases.Changes from a value of type *ChangesResponseBody.
func unmarshalChangesResponseBodyToPurchasesChanges(v *ChangesResponseBody) *purchases.Changes {
	res := &purchases.Changes{
		Coin:   *v.Coin,
		Amount: *v.Amount,
	}

	return res
}
